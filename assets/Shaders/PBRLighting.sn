$name PBR Lighting

@input vec2 vector
@input vec4 diffuse
@input float metallic
@input float specular
@input float roughness
@input vec3 normal

@output vec4 color

#import "Common/ShaderLib/GLSLCompat.glsllib"
#import "Common/ShaderLib/PBR.glsllib"
#import "Common/ShaderLib/Parallax.glsllib"
#import "Common/ShaderLib/Lighting.glsllib"

<static>

uniform vec4 g_LightData[NB_LIGHTS];
uniform vec3 g_CameraPosition;
uniform sampler2D m_LightMap;

varying vec3 wPosition;
varying vec3 wNormal; // this is probably the input normal
varying vec4 wTangent;

</static>
<main>

vec3 viewDir = normalize(g_CameraPosition - wPosition);

vec4 output = vec4(0.0);

// diffuse
vec4 albedo = vec4(diffuse);
float alpha = albedo.a;

// metallic & roughness
float Metallic = metallic;
float Roughness = roughness * max(m_Roughness, 1e-4);

// normals
vec3 norm = normalize(wNormal);
vec3 tan = normalize(wTangent.xyz);
mat3 tbnMat = mat3(tan, wTangent.w * cross( (norm), (tan)), norm);
float normalType = -1.0; // 1.0=OpenGl, -1.0=DirectX
vec4 normalHeight = texture2D(m_NormalMap, newTexCoord);
vec3 normal = normalize((normalHeight.xyz * vec3(2.0, normalType * 2.0, 2.0) - vec3(1.0, normalType * 1.0, 1.0)));
normal = normalize(tbnMat * normal);
normal = norm; // if no normal map is applied

// specular
float specular = 0.5;
float nonMetalSpec = 0.08 * specular;
vec4 specularColor = (nonMetalSpec - nonMetalSpec * Metallic) + albedo * Metallic;
vec4 diffuseColor = albedo - albedo * Metallic;
vec3 fZero = vec3(specular);

// lighting
float ndotv = max( dot( normal, viewDir ),0.0);
for( int i = 0;i < NB_LIGHTS; i+=3){
    vec4 lightColor = g_LightData[i];
    vec4 lightData1 = g_LightData[i+1];                
    vec4 lightDir;
    vec3 lightVec;
    lightComputeDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);

    float fallOff = 1.0;
    #if __VERSION__ >= 110
        // allow use of control flow
    if(lightColor.w > 1.0){
    #endif
        fallOff =  computeSpotFalloff(g_LightData[i+2], lightVec);
    #if __VERSION__ >= 110
    }
    #endif
    //point light attenuation
    fallOff *= lightDir.w;

    lightDir.xyz = normalize(lightDir.xyz);            
    vec3 directDiffuse;
    vec3 directSpecular;

    float hdotv = PBR_ComputeDirectLight(normal, lightDir.xyz, viewDir,
                        lightColor.rgb, fZero, Roughness, ndotv,
                        directDiffuse,  directSpecular);

    vec3 directLighting = diffuseColor.rgb *directDiffuse + directSpecular;

    output.rgb += directLighting * fallOff;
}

output.a = alpha;

</main>